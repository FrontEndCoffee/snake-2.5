(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

const PERSPECTIVE_CONSTANT = 0.875

const shapes = require('./shapes')
const Vector = shapes.Vector
const Line = shapes.Line
const Polygon = shapes.Polygon
const Entity = shapes.Entity

const canvas = document.getElementById('canvas')
const context = canvas.getContext('2d')

const canvasSize = new Vector(canvas.clientWidth, canvas.clientHeight)

const blockSize = new Vector(150, 200)


const position = new Vector(0,0)
const blockShape = new Polygon([
  new Vector( 64,  64),
  new Vector( 64, -64),
  new Vector(-64, -64),
  new Vector(-64,  64)
])

const blockEntity = new Entity(blockShape, position)
blockEntity.position = new Vector(12, 23)


// init
context.translate(canvasSize.x/2, canvasSize.y/2)
context.fillStyle = "rgba(255,255,255,0.9)"
window.ctx = context

window.onmousemove = function(e) {

  const mousePos = new Vector(
    e.clientX - canvas.offsetLeft,
    e.clientY - canvas.offsetTop
  )

  clearFrame()
  drawCursor(mousePos)

  blockEntity.position = mousePos

  // create shadow Entity
  const line = new Line(
    blockEntity.position,
    new Vector(0,0)
  )

  const blockShadowEntity = new Entity(
    blockEntity.verticies,
    blockEntity.position
  )

  const frontpaneVertecies = blockEntity.getVerticies()
  const backpaneVertecies = frontpaneVertecies.map(addPerspective)


  // draw backpane dots (#777)
  context.fillStyle = '#777'
  backpaneVertecies.forEach(function(vertexVector) {
    context.fillRect(vertexVector.x-1, vertexVector.y-1, 3, 3)
  })

  // draw backpane lines (#777)
  context.strokeStyle = '#777'
  backpaneVertecies.forEach(function(vertexVector, i, vertecies) {
    const nextVertex = vertecies[(i + 1) % vertecies.length]
    drawLine(vertexVector, nextVertex)
  })

  // draw middle lines (#bbb)
  context.strokeStyle = '#bbb'
  backpaneVertecies.forEach(function(vertexVector, i) {
    const frontpaneVertex = frontpaneVertecies[i]
    drawLine(vertexVector, frontpaneVertex)
  })

  // draw frontpane lines (#fff)
  context.strokeStyle = '#fff'
  frontpaneVertecies.forEach(function(vertexVector, i, vertecies) {
    const nextVertex = vertecies[(i + 1) % vertecies.length]
    drawLine(vertexVector, nextVertex)
  })

  // draw frontpane dots (#fff)
  context.fillStyle = '#fff'
  frontpaneVertecies.forEach(function(vertexVector) {
    context.fillRect(vertexVector.x-1, vertexVector.y-1, 3, 3)
  })


}

function clearFrame() {
  context.clearRect(
    -canvasSize.x/2,
    -canvasSize.y/2,
    canvasSize.x,
    canvasSize.y
  )
}

function drawLine(vector1, vector2) {
  context.beginPath()
  context.moveTo(vector1.x, vector1.y)
  context.lineTo(vector2.x, vector2.y)
  context.stroke()
}

function addPerspective(vertexVector) {
  return new Vector(
    vertexVector.x * PERSPECTIVE_CONSTANT,
    vertexVector.y * PERSPECTIVE_CONSTANT
  )
}

function drawCursor(mousePosVec) {
  const oldStyle = context.fillStyle
  context.fillStyle = '#fff'
  context.fillRect(mousePosVec.x-5, mousePosVec.y-1, 10, 2)
  context.fillRect(mousePosVec.x-1, mousePosVec.y-5, 2, 10)
  context.fillStyle = oldStyle
}

},{"./shapes":2}],2:[function(require,module,exports){
'use strict'

function Vector(x,y) {
  this.x = x
  this.y = y
}
Vector.prototype.add = function(vector) {
  return new Vector(
    this.x + vector.x,
    this.y + vector.y
  )
}

function Line(v1, v2) {
  this.v1 = v1
  this.v2 = v2
}
Line.prototype.getDeltaX = function() {
  return this.v2.x - this.v1.x
}
Line.prototype.getDeltaY = function() {
  return this.v2.y - this.v1.y
}
Line.prototype.getLength = function() {
  return Math.sqrt(
    Math.pow(this.getDeltaX(), 2) +
    Math.pow(this.getDeltaY(), 2)
  )
}

function Polygon(vectors) {
  if (vectors.length < 3) throw 'Polygon must have at least 3 verticies'
  this.verticies = vectors
}

function Entity(shape, position) {
  this.shape = shape
  this.position = position
}
Entity.prototype.getVerticies = function() {
  const position = this.position
  return this.shape.verticies.map(function(vertexVector) {
    return vertexVector.add(position)
  })
}
Entity.prototype.translate = function(vector) {
  this.position = this.position.add(vector)
}

module.exports = {
  Vector: Vector,
  Line: Line,
  Polygon: Polygon,
  Entity: Entity
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvanMvc3JjL2FwcC5qcyIsImFwcC9qcy9zcmMvc2hhcGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBQRVJTUEVDVElWRV9DT05TVEFOVCA9IDAuODc1XG5cbmNvbnN0IHNoYXBlcyA9IHJlcXVpcmUoJy4vc2hhcGVzJylcbmNvbnN0IFZlY3RvciA9IHNoYXBlcy5WZWN0b3JcbmNvbnN0IExpbmUgPSBzaGFwZXMuTGluZVxuY29uc3QgUG9seWdvbiA9IHNoYXBlcy5Qb2x5Z29uXG5jb25zdCBFbnRpdHkgPSBzaGFwZXMuRW50aXR5XG5cbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKVxuY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbmNvbnN0IGNhbnZhc1NpemUgPSBuZXcgVmVjdG9yKGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodClcblxuY29uc3QgYmxvY2tTaXplID0gbmV3IFZlY3RvcigxNTAsIDIwMClcblxuXG5jb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IoMCwwKVxuY29uc3QgYmxvY2tTaGFwZSA9IG5ldyBQb2x5Z29uKFtcbiAgbmV3IFZlY3RvciggNjQsICA2NCksXG4gIG5ldyBWZWN0b3IoIDY0LCAtNjQpLFxuICBuZXcgVmVjdG9yKC02NCwgLTY0KSxcbiAgbmV3IFZlY3RvcigtNjQsICA2NClcbl0pXG5cbmNvbnN0IGJsb2NrRW50aXR5ID0gbmV3IEVudGl0eShibG9ja1NoYXBlLCBwb3NpdGlvbilcbmJsb2NrRW50aXR5LnBvc2l0aW9uID0gbmV3IFZlY3RvcigxMiwgMjMpXG5cblxuLy8gaW5pdFxuY29udGV4dC50cmFuc2xhdGUoY2FudmFzU2l6ZS54LzIsIGNhbnZhc1NpemUueS8yKVxuY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMjU1LDI1NSwyNTUsMC45KVwiXG53aW5kb3cuY3R4ID0gY29udGV4dFxuXG53aW5kb3cub25tb3VzZW1vdmUgPSBmdW5jdGlvbihlKSB7XG5cbiAgY29uc3QgbW91c2VQb3MgPSBuZXcgVmVjdG9yKFxuICAgIGUuY2xpZW50WCAtIGNhbnZhcy5vZmZzZXRMZWZ0LFxuICAgIGUuY2xpZW50WSAtIGNhbnZhcy5vZmZzZXRUb3BcbiAgKVxuXG4gIGNsZWFyRnJhbWUoKVxuICBkcmF3Q3Vyc29yKG1vdXNlUG9zKVxuXG4gIGJsb2NrRW50aXR5LnBvc2l0aW9uID0gbW91c2VQb3NcblxuICAvLyBjcmVhdGUgc2hhZG93IEVudGl0eVxuICBjb25zdCBsaW5lID0gbmV3IExpbmUoXG4gICAgYmxvY2tFbnRpdHkucG9zaXRpb24sXG4gICAgbmV3IFZlY3RvcigwLDApXG4gIClcblxuICBjb25zdCBibG9ja1NoYWRvd0VudGl0eSA9IG5ldyBFbnRpdHkoXG4gICAgYmxvY2tFbnRpdHkudmVydGljaWVzLFxuICAgIGJsb2NrRW50aXR5LnBvc2l0aW9uXG4gIClcblxuICBjb25zdCBmcm9udHBhbmVWZXJ0ZWNpZXMgPSBibG9ja0VudGl0eS5nZXRWZXJ0aWNpZXMoKVxuICBjb25zdCBiYWNrcGFuZVZlcnRlY2llcyA9IGZyb250cGFuZVZlcnRlY2llcy5tYXAoYWRkUGVyc3BlY3RpdmUpXG5cblxuICAvLyBkcmF3IGJhY2twYW5lIGRvdHMgKCM3NzcpXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJyM3NzcnXG4gIGJhY2twYW5lVmVydGVjaWVzLmZvckVhY2goZnVuY3Rpb24odmVydGV4VmVjdG9yKSB7XG4gICAgY29udGV4dC5maWxsUmVjdCh2ZXJ0ZXhWZWN0b3IueC0xLCB2ZXJ0ZXhWZWN0b3IueS0xLCAzLCAzKVxuICB9KVxuXG4gIC8vIGRyYXcgYmFja3BhbmUgbGluZXMgKCM3NzcpXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIzc3NydcbiAgYmFja3BhbmVWZXJ0ZWNpZXMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhWZWN0b3IsIGksIHZlcnRlY2llcykge1xuICAgIGNvbnN0IG5leHRWZXJ0ZXggPSB2ZXJ0ZWNpZXNbKGkgKyAxKSAlIHZlcnRlY2llcy5sZW5ndGhdXG4gICAgZHJhd0xpbmUodmVydGV4VmVjdG9yLCBuZXh0VmVydGV4KVxuICB9KVxuXG4gIC8vIGRyYXcgbWlkZGxlIGxpbmVzICgjYmJiKVxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyNiYmInXG4gIGJhY2twYW5lVmVydGVjaWVzLmZvckVhY2goZnVuY3Rpb24odmVydGV4VmVjdG9yLCBpKSB7XG4gICAgY29uc3QgZnJvbnRwYW5lVmVydGV4ID0gZnJvbnRwYW5lVmVydGVjaWVzW2ldXG4gICAgZHJhd0xpbmUodmVydGV4VmVjdG9yLCBmcm9udHBhbmVWZXJ0ZXgpXG4gIH0pXG5cbiAgLy8gZHJhdyBmcm9udHBhbmUgbGluZXMgKCNmZmYpXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnI2ZmZidcbiAgZnJvbnRwYW5lVmVydGVjaWVzLmZvckVhY2goZnVuY3Rpb24odmVydGV4VmVjdG9yLCBpLCB2ZXJ0ZWNpZXMpIHtcbiAgICBjb25zdCBuZXh0VmVydGV4ID0gdmVydGVjaWVzWyhpICsgMSkgJSB2ZXJ0ZWNpZXMubGVuZ3RoXVxuICAgIGRyYXdMaW5lKHZlcnRleFZlY3RvciwgbmV4dFZlcnRleClcbiAgfSlcblxuICAvLyBkcmF3IGZyb250cGFuZSBkb3RzICgjZmZmKVxuICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZmZmJ1xuICBmcm9udHBhbmVWZXJ0ZWNpZXMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhWZWN0b3IpIHtcbiAgICBjb250ZXh0LmZpbGxSZWN0KHZlcnRleFZlY3Rvci54LTEsIHZlcnRleFZlY3Rvci55LTEsIDMsIDMpXG4gIH0pXG5cblxufVxuXG5mdW5jdGlvbiBjbGVhckZyYW1lKCkge1xuICBjb250ZXh0LmNsZWFyUmVjdChcbiAgICAtY2FudmFzU2l6ZS54LzIsXG4gICAgLWNhbnZhc1NpemUueS8yLFxuICAgIGNhbnZhc1NpemUueCxcbiAgICBjYW52YXNTaXplLnlcbiAgKVxufVxuXG5mdW5jdGlvbiBkcmF3TGluZSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGNvbnRleHQuYmVnaW5QYXRoKClcbiAgY29udGV4dC5tb3ZlVG8odmVjdG9yMS54LCB2ZWN0b3IxLnkpXG4gIGNvbnRleHQubGluZVRvKHZlY3RvcjIueCwgdmVjdG9yMi55KVxuICBjb250ZXh0LnN0cm9rZSgpXG59XG5cbmZ1bmN0aW9uIGFkZFBlcnNwZWN0aXZlKHZlcnRleFZlY3Rvcikge1xuICByZXR1cm4gbmV3IFZlY3RvcihcbiAgICB2ZXJ0ZXhWZWN0b3IueCAqIFBFUlNQRUNUSVZFX0NPTlNUQU5ULFxuICAgIHZlcnRleFZlY3Rvci55ICogUEVSU1BFQ1RJVkVfQ09OU1RBTlRcbiAgKVxufVxuXG5mdW5jdGlvbiBkcmF3Q3Vyc29yKG1vdXNlUG9zVmVjKSB7XG4gIGNvbnN0IG9sZFN0eWxlID0gY29udGV4dC5maWxsU3R5bGVcbiAgY29udGV4dC5maWxsU3R5bGUgPSAnI2ZmZidcbiAgY29udGV4dC5maWxsUmVjdChtb3VzZVBvc1ZlYy54LTUsIG1vdXNlUG9zVmVjLnktMSwgMTAsIDIpXG4gIGNvbnRleHQuZmlsbFJlY3QobW91c2VQb3NWZWMueC0xLCBtb3VzZVBvc1ZlYy55LTUsIDIsIDEwKVxuICBjb250ZXh0LmZpbGxTdHlsZSA9IG9sZFN0eWxlXG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gVmVjdG9yKHgseSkge1xuICB0aGlzLnggPSB4XG4gIHRoaXMueSA9IHlcbn1cblZlY3Rvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gIHJldHVybiBuZXcgVmVjdG9yKFxuICAgIHRoaXMueCArIHZlY3Rvci54LFxuICAgIHRoaXMueSArIHZlY3Rvci55XG4gIClcbn1cblxuZnVuY3Rpb24gTGluZSh2MSwgdjIpIHtcbiAgdGhpcy52MSA9IHYxXG4gIHRoaXMudjIgPSB2MlxufVxuTGluZS5wcm90b3R5cGUuZ2V0RGVsdGFYID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnYyLnggLSB0aGlzLnYxLnhcbn1cbkxpbmUucHJvdG90eXBlLmdldERlbHRhWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52Mi55IC0gdGhpcy52MS55XG59XG5MaW5lLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICBNYXRoLnBvdyh0aGlzLmdldERlbHRhWCgpLCAyKSArXG4gICAgTWF0aC5wb3codGhpcy5nZXREZWx0YVkoKSwgMilcbiAgKVxufVxuXG5mdW5jdGlvbiBQb2x5Z29uKHZlY3RvcnMpIHtcbiAgaWYgKHZlY3RvcnMubGVuZ3RoIDwgMykgdGhyb3cgJ1BvbHlnb24gbXVzdCBoYXZlIGF0IGxlYXN0IDMgdmVydGljaWVzJ1xuICB0aGlzLnZlcnRpY2llcyA9IHZlY3RvcnNcbn1cblxuZnVuY3Rpb24gRW50aXR5KHNoYXBlLCBwb3NpdGlvbikge1xuICB0aGlzLnNoYXBlID0gc2hhcGVcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uXG59XG5FbnRpdHkucHJvdG90eXBlLmdldFZlcnRpY2llcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb25cbiAgcmV0dXJuIHRoaXMuc2hhcGUudmVydGljaWVzLm1hcChmdW5jdGlvbih2ZXJ0ZXhWZWN0b3IpIHtcbiAgICByZXR1cm4gdmVydGV4VmVjdG9yLmFkZChwb3NpdGlvbilcbiAgfSlcbn1cbkVudGl0eS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gIHRoaXMucG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmFkZCh2ZWN0b3IpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBWZWN0b3I6IFZlY3RvcixcbiAgTGluZTogTGluZSxcbiAgUG9seWdvbjogUG9seWdvbixcbiAgRW50aXR5OiBFbnRpdHlcbn1cbiJdfQ==
